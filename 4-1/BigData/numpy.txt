4.1 NumPy ndarray: 다차원 배열 객체

>>> import numpy as np
>>> data = [0.956,-0.24,2],[0.2232, 1.232, 4]
>>> data = np.array(data)
>>> print(data)
[[ 0.956  -0.24    2.    ]
 [ 0.2232  1.232   4.    ]]
>>> print(data.dtype, data.ndim, data.shape)
float64 2 (2, 3)

4.1.1 ndarray 생성

>>> np.zeros(10)
array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
>>> np.zeros((3,6))
array([[0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.]])
>>> np.empty((2,3,2))
array([[[8.82769181e+025, 7.36662981e+228],
        [7.54894003e+252, 2.95479883e+137],
        [1.42800637e+248, 2.64686750e+180]],

       [[1.09936856e+248, 6.99481925e+228],
        [7.54894003e+252, 7.67109635e+170],
        [2.64686750e+180, 5.63234836e-322]]])
>>> np.arange(15)
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])

>>> arr = np.array([1,2,3,4,5])
>>> print(arr.dtype)
int32
>>> arr.astype(np.float64)
array([1., 2., 3., 4., 5.])

4.1.3 NumPy : 배열과 스칼라 간의 연산

>>> arr = np.array([np.arange(1,5),np.arange(6,10)])
>>> print(arr)
[[1 2 3 4]
 [6 7 8 9]]
>>> arr2 = arr + arr
>>> print(arr2)
[[ 2  4  6  8]
 [12 14 16 18]]
>>> print(arr*arr2)
[[  2   8  18  32]
 [ 72  98 128 162]]
>>> print(arr * 3)
[[ 3  6  9 12]
 [18 21 24 27]]

>>> l1 = [1,2,3,4,5,]
>>> l2 = l1[0:3]
>>> l2
[1, 2, 3]
>>> l2[0] = 122
>>> l1,l2
([1, 2, 3, 4, 5], [122, 2, 3])

>>> arr = np.array(np.arange(10))
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> arr2 = arr[0:4]
>>> arr2[0] = 123
>>> arr2
array([123,   1,   2,   3])
>>> arr
array([123,   1,   2,   3,   4,   5,   6,   7,   8,   9])

>>> arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])
>>> arr2d[2]
array([7, 8, 9])
>>> arr2d[0][2]
3
>>> arr2d[0,2]
3

>>> arr3d = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])
>>> arr3d
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d[0]
array([[1, 2, 3],
       [4, 5, 6]])
>>> old_values = arr3d[0].copy()
>>> arr3d[0] = 42
>>> arr3d
array([[[42, 42, 42],
        [42, 42, 42]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d[0] = old_values
>>> arr3d
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
>>> arr3d[1,0]
array([7, 8, 9])

>>> arr2d
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> arr2d[:2]
array([[1, 2, 3],
       [4, 5, 6]])
>>> arr2d[:2,1:]
array([[2, 3],
       [5, 6]])
>>> arr2d[1,:2]
array([4, 5])
>>> arr2d[2,:1]
array([7])
>>> arr2d[:,:1]
array([[1],
       [4],
       [7]])
>>> arr2d[:2,1:] = 0
>>> arr2d
array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])

4.1.5 NumPy : 불리언 색인

>>> names = np.array(['Bob','Jeo','Will','Bob','Will','Joe','Joe'])
>>> names
array(['Bob', 'Jeo', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')
>>> data = np.random.randn(7,4)
>>> data
array([[ 1.9740773 , -0.6423962 , -0.2006756 ,  0.52525623],
       [-1.20193312, -1.38313181,  0.3961351 , -0.8188095 ],
       [ 0.33524588, -0.44175992,  1.64634463,  0.0378465 ],
       [ 1.72328732, -1.32244218,  0.42115578, -0.42953945],
       [-0.44070549, -0.51545025,  0.13445802, -0.10692469],
       [ 0.37755489, -1.23529643, -2.25869924,  1.60539543],
       [-0.80347369,  2.25710957, -0.11955058, -0.22134839]])

>>> data[names == 'Bob']
array([[ 1.9740773 , -0.6423962 , -0.2006756 ,  0.52525623],
       [ 1.72328732, -1.32244218,  0.42115578, -0.42953945]])
>>> data[names == 'Bob',2:]
array([[-0.2006756 ,  0.52525623],
       [ 0.42115578, -0.42953945]])
>>> data[names!='Bob']
array([[-1.20193312, -1.38313181,  0.3961351 , -0.8188095 ],
       [ 0.33524588, -0.44175992,  1.64634463,  0.0378465 ],
       [-0.44070549, -0.51545025,  0.13445802, -0.10692469],
       [ 0.37755489, -1.23529643, -2.25869924,  1.60539543],
       [-0.80347369,  2.25710957, -0.11955058, -0.22134839]])

>>> data[names != 'Joe'] = 7
>>> data
array([[ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 7.        ,  7.        ,  7.        ,  7.        ],
       [ 0.37755489, -1.23529643, -2.25869924,  1.60539543],
       [-0.80347369,  2.25710957, -0.11955058, -0.22134839]])

>>> arr = np.empty((8,4))
>>> for i in range(8):
	arr[i] = i	
>>> arr
array([[0., 0., 0., 0.],
       [1., 1., 1., 1.],
       [2., 2., 2., 2.],
       [3., 3., 3., 3.],
       [4., 4., 4., 4.],
       [5., 5., 5., 5.],
       [6., 6., 6., 6.],
       [7., 7., 7., 7.]])
>>> arr[[4,3,0,6]]
array([[4., 4., 4., 4.],
       [3., 3., 3., 3.],
       [0., 0., 0., 0.],
       [6., 6., 6., 6.]])
>>> arr[[-3,-5,-7]]
array([[5., 5., 5., 5.],
       [3., 3., 3., 3.],
       [1., 1., 1., 1.]])

>>> arr = np.arange(32).reshape((8,4))
>>> arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
>>> arr[[1,5,7,2],[0,3,1,2]]
array([ 4, 23, 29, 10])
>>> arr[np.ix_([1,5,7,2],[0,3,1,2])]
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
>>> arr[[1,5,7,2]][:,[0,3,1,2]]
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])

4.1.7 NumPy : 배열 전치와 축 바꾸기

>>> arr = np.arange(15).reshape((3,5))
>>> arr
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> arr.T
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])
>>> arr = np.random.randn(6,3)
>>> np.dot(arr.T,arr)
array([[ 1.20098271, -0.5637434 , -1.68187323],
       [-0.5637434 ,  1.59976176,  1.85164361],
       [-1.68187323,  1.85164361,  5.4600178 ]])

>>> arr = np.arange(16).reshape((2,2,4))
>>> arr
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
>>> arr.transpose((1,0,2))
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
>>> arr.swapaxes(1,2)
array([[[ 0,  4],
        [ 1,  5],
        [ 2,  6],
        [ 3,  7]],

       [[ 8, 12],
        [ 9, 13],
        [10, 14],
        [11, 15]]])

4.2 NumPy : 유니버설 함수

>>> arr = np.arange(10)
>>> np.sqrt(arr)
array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])
>>> np.exp(arr)
array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
       5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
       2.98095799e+03, 8.10308393e+03])

>>> x = np.random.randn(8)
>>> y = np.random.randn(8)
>>> x
array([ 1.60519159, -1.53607891, -0.4691592 , -0.09241472, -1.93620717,
        0.90573881,  0.30840929,  0.34941572])
>>> y
array([ 0.18636413, -0.02669649, -0.44734895, -0.48458581, -2.55853737,
       -0.52381936,  2.76251787,  0.12398796])
>>> np.maximum(x,y)
array([ 1.60519159, -0.02669649, -0.44734895, -0.09241472, -1.93620717,
        0.90573881,  2.76251787,  0.34941572])
>>> arr = np.random.randn(7)*5
>>> arr
array([ 3.57766722, -0.07988257, -6.64662285, -0.36521328, -0.07804947,
       -0.89641346,  2.37361685])
>>> np.modf(arr)
(array([ 0.57766722, -0.07988257, -0.64662285, -0.36521328, -0.07804947,
       -0.89641346,  0.37361685]), array([ 3., -0., -6., -0., -0., -0.,  2.]))

4.3 NumPy : 배열을 사용한 데이터 처리

>>> points = np.arange(-5,5,0.01)
>>> xs,ys = np.meshgrid(points,points)
>>> ys
array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
       ...,
       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])

>>> import matplotlib.pyplot as plt
>>> z = np.sqrt(xs**2 + ys**2)
>>> z
array([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,
        7.06400028],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       ...,
       [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,
        7.04279774],
       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,
        7.04985815],
       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,
        7.05692568]])
>>> plt.imshow(z,cmap=plt.cm.gray); plt.colorbar()
<matplotlib.image.AxesImage object at 0x0000016BD4869C88>
<matplotlib.colorbar.Colorbar object at 0x0000016BD60255C0>
>>> plt.title("Image plot of $\sqrt{x^2 + y^2}$ for a grid of values")
Text(0.5, 1.0, 'Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values')

4.3.1 NumPy : 배열연산으로 조건절 표현하기

>>> xarr = np.array([1.1,1.2,1.3,1.4,1.5])
>>> yarr = np.array([2.1,2.2,2.3,2.4,2.5])
>>> cond = np.array([True, False, True, True, False])
>>> result = [(x if c else y) for x,v,c in zip(xarr,yarr,cond)]
>>> result
[1.1, array([ 0.18636413, -0.02669649, -0.44734895, -0.48458581, -2.55853737,
       -0.52381936,  2.76251787,  0.12398796]), 1.3, 1.4, array([ 0.18636413, -0.02669649, -0.44734895, -0.48458581, -2.55853737,
       -0.52381936,  2.76251787,  0.12398796])]
>>> result = np.where(cond, xarr, yarr)
>>> result
array([1.1, 2.2, 1.3, 1.4, 2.5])
>>> arr = np.random.randn(4,4)
>>> arr
array([[ 2.06643809, -0.81433367,  0.38915453, -1.37674211],
       [ 0.29637667, -0.02771989,  1.51383955, -0.41531099],
       [ 0.02396958, -0.22331415, -0.18722219,  0.68034655],
       [-2.53176621, -0.99091951, -0.53571944, -0.51146742]])
>>> np.where(arr>0, 2, -2)
array([[ 2, -2,  2, -2],
       [ 2, -2,  2, -2],
       [ 2, -2, -2,  2],
       [-2, -2, -2, -2]])

4.3.2 NumPy : 수학 메쏘드, 통계 메쏘드

>>> arr = np.random.randn(5,4)
>>> arr.mean()
-0.09995702213567718
>>> np.mean(arr)
-0.09995702213567718
>>> arr.sum()
-1.9991404427135437
>>> arr.mean(axis=1)
array([-0.05887409,  0.01932997,  0.20635537,  0.02683921, -0.69343557])
>>> arr.sum(0)
array([-1.28438726, -2.05299039,  0.52739319,  0.81084401])
>>> arr = np.array([[0,1,2],[3,4,5],[6,7,8]])
>>> arr.cumsum(0)
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]], dtype=int32)
>>> arr.cumprod(1)
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]], dtype=int32)

4.3.3 불리언 배열을 위한 메서드

>>> arr = np.random.randn(100)
>>> (arr>0).sum()
47
>>> bools = np.array([False, False, True, False])
>>> bools.any()
True
>>> bools.all()
False
>>> arr = np.random.rand(8)
>>> arr
array([0.71506478, 0.02927177, 0.303171  , 0.8829427 , 0.8782945 ,
       0.17436498, 0.80029264, 0.19357327])

4.3.4 정렬

>>> arr = np.random.rand(5,3)
>>> arr
array([[0.58840359, 0.59657816, 0.60744851],
       [0.4892522 , 0.31273081, 0.51488455],
       [0.36704876, 0.64065327, 0.90939132],
       [0.43538346, 0.35961775, 0.78570915],
       [0.53038903, 0.45631959, 0.36200366]])
>>> arr.sort(1)
>>> arr
array([[0.58840359, 0.59657816, 0.60744851],
       [0.31273081, 0.4892522 , 0.51488455],
       [0.36704876, 0.64065327, 0.90939132],
       [0.35961775, 0.43538346, 0.78570915],
       [0.36200366, 0.45631959, 0.53038903]])
>>> large_arr = np.random.randn(1000)
>>> large_arr.sort()
>>> large_arr[int(0.05 * len(large_arr))]
-1.6116583512348925

>>> names = np.array(['Bob','Joe','Will','Bob','Will','Joe','Joe'])
>>> np.unique(names)
array(['Bob', 'Joe', 'Will'], dtype='<U4')
>>> ints = np.array([3,3,3,2,2,1,1,4,4])
>>> np.unique(ints)
array([1, 2, 3, 4])
>>> sorted(set(names))
['Bob', 'Joe', 'Will']
>>> values = np.array([6,0,0,3,2,5,6])
>>> np.in1d(values, [2,3,6])
array([ True, False, False,  True,  True, False,  True])

4.4 NumPy : 배열 파일 입,출력

>>> arr = np.arange(10)
>>> np.save('some_array',arr)
>>> np.load('some_array.npy')
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> np.savez('array_archive.npz',a=arr,b=arr)
>>> arch = np.load('array_archive.npz')
>>> arch['b']
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

4.4.2 텍스트 파일 불러오기 저장하기.

>>> np.savetxt('array_ex.txt',arr)
>>> arr = np.loadtxt('array_ex.txt',delimiter=',')
>>> arr
array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])

4.5 NumPy : 선형대수

>>> x = np.array([[1.,2.,3.],[4.,5.,6]])
>>> y = np.array([[6.,23.],[-1,7],[8,9]])
>>> x
array([[1., 2., 3.],
       [4., 5., 6.]])
>>> y
array([[ 6., 23.],
       [-1.,  7.],
       [ 8.,  9.]])
>>> x.dot(y)
array([[ 28.,  64.],
       [ 67., 181.]])
>>> np.dot(x,np.ones(3))
array([ 6., 15.])

>>> from numpy.linalg import inv,qr
>>> X = np.random.randn(5,5)
>>> mat = X.T.dot(X)
>>> inv(mat)
array([[ 3.44402795,  1.37227227,  0.90227274, -1.8360607 ,  0.98842   ],
       [ 1.37227227,  0.99157994, -0.36610373, -0.96737351, -0.83599756],
       [ 0.90227274, -0.36610373,  3.428112  ,  0.45608588,  4.35752869],
       [-1.8360607 , -0.96737351,  0.45608588,  1.36365968,  0.74078325],
       [ 0.98842   , -0.83599756,  4.35752869,  0.74078325,  6.10203613]])
>>> mat.dot(inv(mat))
array([[ 1.00000000e+00, -8.28336015e-16, -1.52773789e-15,
         1.07796423e-15, -1.39128075e-15],
       [ 2.31251308e-15,  1.00000000e+00, -7.47606883e-16,
        -1.66731481e-15, -3.30001154e-15],
       [ 6.14101387e-16,  8.18377970e-17,  1.00000000e+00,
         1.19096336e-15, -1.05395932e-15],
       [-1.41193386e-15, -3.77829142e-16, -2.02741000e-16,
         1.00000000e+00,  3.10712306e-16],
       [ 1.24123279e-15, -2.72496415e-16,  1.11225170e-15,
        -1.16396017e-15,  1.00000000e+00]])
>>> q,r = qr(mat)
>>> r
array([[-10.20717749,   8.23433456,  -3.05874506, -10.77195725,
          6.32043577],
       [  0.        ,  -7.61204265,   6.3126051 ,  -5.21669717,
         -4.96665335],
       [  0.        ,   0.        ,  -3.31303509,  -0.36716154,
          2.48192251],
       [  0.        ,   0.        ,   0.        ,  -0.4016817 ,
          0.04475241],
       [  0.        ,   0.        ,   0.        ,   0.        ,
          0.13080277]])

4.7 NumPy : 계단 오르내리기 예제

>>> import random
>>> import matplotlib.pyplot as plt
>>> position = 0
>>> walk = [position]
>>> steps = 10
>>> for i in range(steps):
	step = 1 if random.randint(0,1) else -1
	position += step
	walk.append(position)	
>>> print(walk)
[0, 1, 2, 1, 0, -1, -2, -3, -4, -3, -4]
>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> plt.plot(walk)
[<matplotlib.lines.Line2D object at 0x0000016BD3A50438>]
>>> plt.show()

>>> nsteps = 10
>>> draws = np.random.randint(0,2,size=nsteps)
>>> print(draws)
[1 0 1 1 0 1 0 1 1 0]
>>> steps = np.where(draws > 0, 1, -1)
>>> walk = steps.cumsum()
>>> print(walk)
[1 0 1 2 1 2 1 2 3 2]
>>> print(walk.min())
0
>>> print(walk.max())
3
>>> tval = 2
>>> print((np.abs(walk) >= tval).argmax())
3

4.7.1 계단 오르기 시뮬레이션, jupyter notebook 이용 설명이 용이

>>> nwalks=5
>>> nsteps = 10
>>> tval =3
>>> draws = np.random.randint(0,2,size=(nwalks, nsteps))
>>> print(draws)
[[1 0 0 1 0 1 0 0 1 1]
 [0 1 0 0 0 1 0 0 1 1]
 [1 0 0 0 0 1 0 0 0 1]
 [0 1 0 0 0 1 1 0 1 1]
 [1 1 1 0 1 1 1 0 1 1]]
>>> steps=np.where(draws>0,1,-1)
>>> print(steps)
[[ 1 -1 -1  1 -1  1 -1 -1  1  1]
 [-1  1 -1 -1 -1  1 -1 -1  1  1]
 [ 1 -1 -1 -1 -1  1 -1 -1 -1  1]
 [-1  1 -1 -1 -1  1  1 -1  1  1]
 [ 1  1  1 -1  1  1  1 -1  1  1]]
>>> walks=steps.cumsum(1)
>>> print(walks)
[[ 1  0 -1  0 -1  0 -1 -2 -1  0]
 [-1  0 -1 -2 -3 -2 -3 -4 -3 -2]
 [ 1  0 -1 -2 -3 -2 -3 -4 -5 -4]
 [-1  0 -1 -2 -3 -2 -1 -2 -1  0]
 [ 1  2  3  2  3  4  5  4  5  6]]
>>> hits30=(np.abs(walks)>=3).any(1)
>>> print(hits30)
[False  True  True  True  True]
>>> print(hits30.sum())
4
>>> print(walks[hits30])
[[-1  0 -1 -2 -3 -2 -3 -4 -3 -2]
 [ 1  0 -1 -2 -3 -2 -3 -4 -5 -4]
 [-1  0 -1 -2 -3 -2 -1 -2 -1  0]
 [ 1  2  3  2  3  4  5  4  5  6]]
>>> print(np.abs(walks[hits30])>=3)
[[False False False False  True False  True  True  True False]
 [False False False False  True False  True  True  True  True]
 [False False False False  True False False False False False]
 [False False  True False  True  True  True  True  True  True]]
>>> crossing_times = (np.abs(walks[hits30])>=3).argmax(1)
>>> print(crossing_times)
[4 4 4 2]
>>> print(crossing_times.mean())
3.5

>>> np.random.seed(100)
>>> nsteps = 10
>>> steps = np.random.randint(-2,3,nsteps)
>>> walk = steps.cumsum()
>>> print(steps)
[-2 -2  1 -2  0  2  0  0  0  0]
>>> print('계단이동 변화')
계단이동 변화
>>> print(walk)
[-2 -4 -3 -5 -5 -3 -3 -3 -3 -3]
>>> plt.figure()
<Figure size 640x480 with 0 Axes>
>>> plt.plot(walk)
[<matplotlib.lines.Line2D object at 0x0000016BD3D52F98>]
>>> plt.show()
>>> print('최고계단=%d, 최저계단%d'%(walk.max(),walk.min()))
최고계단=-2, 최저계단-5
>>> print('0으로 회괴 회수%d'%(walk==0).sum())
0으로 회괴 회수0





























