중간고사: 4월 마지막 5월 초
3월 29(금) 9-10교시
4월 1일 11-12교시
4월 5일 10-11교시

게임프로그래밍은 일반적인 프로그래밍(문제가 주어지는)과 달리
문제를 만들어내고 문제를 규정하는데 이 과정을 게임기획이라고 한다.

내부의 데이터의 표현이 3D인지 2D인지에 따라 
3D게임인지 2D게임인지가 나뉜다.

데이터도3D 구현(화면출력)도 3D처리를 하면 3D게임이라고 할 수 있다.

-수업내용-
T&L
Transform 선형대수학 이동변환(atem?어템포), 신축-회전(선형변환)
Lighting 변환된것을 화면에 표현하는것.

변환을 위한 수학= 벡터,행렬

GameFramework 게임의 골격을 만들어본다.

Shader Programming GPU를 사용하기 위해
--------------------------
게임에는 여러가지 처리과정이 있다.
과정중 화면에 그리기위한 과정을 렌더링이라하고
3차원 -> 2차원
처리를 해주는 엔진을 렌더링 엔진, 그래픽스 엔진이라 한다.
(컴퓨터를 이용하기때문에 수학적인 방법을 이용해야한다.)

기하학적 모델링
메쉬-다각형의집합-삼각형의집합-선분들의집합-점(벡터)들의집합
-실수들의 집합
렌더링은 선분을 그리는것이 아니라 면을 그리는 것(색)
입체의 기본단위는 육면체
입체중 그릴범위를 판단하는것도 벡터와 행렬을 사용하여한다

원은 3개의 실수로 그릴 수 있지만 3D모델은 그렇지 않기때문에
점들의 집합으로 나타내었고 이것을 표현하는걸 기하학적 모델링이라고
한다.

2차원에서의 기하학
좌표계
화면좌표계는 직교좌표계와는 달리 정수만 사용한다(픽셀의 위치를 나타내기 때문)
화면좌표계는 2D이지만 게임상에서는 직교 3차원 좌표계
다이렉트X는 왼손좌표계 Opengl은 오른손좌표계

왼손좌표계 x,y,z가 시계방향, 오른손좌표계 x,y,z가 반시계방향
왼손은 멀리 떨어져있는(z)가 수가 크다.

3차원의 좌표를 표현하려면 최소 3개의 벡터가 필요하다.
세개의 기저벡터(스칼라곱과 덧셈) (1,0,0), (0,1,0), (0,0,1)의 선형결합으로
스칼라곱과 덧셈으로 정의할수 있는 어떤것 = 벡터

메쉬 - 다각형들의집합 - 점들의 집합 - 순서쌍들의 집합
struct{ x, y, z} -> 순서쌍

오브젝트의 위치와 방향이 바뀌는것 - 애니메이션
큐브의 회전, 위치이동(Transform)

위치와 방향을 바꾸기위한 프로그램을 만드는것

모델을 표현
모델을 표현하기위한 좌표계 - 모델좌표계
게임세상을 표현하기위한 좌표계 - 월드좌표계 - 딱 하나 존재

메쉬와 모델의 원점은 같을 필요는 없지만 같으면 좋다.

모델, 위치, 방향 - 메쉬를 표현하기 위한 3가지

메쉬와 텍스쳐매핑

원기둥을 무한대의 폴리곤으로 나타낼수 없기때문에 수를 제한하고,
그 폴리곤들에 텍스쳐를 '매핑'
(Map = 2D이미지)
Height Map 높이를 2D로
Bump Map 표면의 요철을 표현

1. Batch
OverHead 를 줄이기 위해 일괄처리

2. 미리 계산
정적(static)인 것들을 미리계산

게임의 1순위 Frame Rate

다각형 와인딩 순서
FrontFace 화면에 보이는 면
BackFace 화면에 보이지 않는 면(은면)
culling - 처리계산에서 뺀다.

polyGon 표현을 위해서 정점을 나열해야 한다. 시계방향
Winding Order 시계방향(보이는면), 반시계방향(안보이는면)
항상 보일때를 기준으로 해서 시계방향

Scene(게임월드자체 하나!) 을 표현할때 같은 렌더링을 사용한다.
Scene = 게임오브젝트의 배열
게임오브젝트를 그린다-> 모델을 그린다->polygon을 그린다
다각형-> 픽셀로 변환(transform) -> 픽셀들의 집합
픽셀들의 색을 결정-Lighting

픽셀을 어떻게 찾아낼것인지
렌더링(T&L 중 T)
변환 파이프라인(transform 과정)
투영변환 n차원 -> n-1차원 (원근 알고리즘 필요)
모델의 점을 화면에 표시되기까지의 변화과정

Primitives = Polygon
이동 -> 위치
회전 -> 방향

함수= 변환의 한 예
x 와 y 집합의 상관관계f 에 대해 x의 결과값이 하나만 나오는 경우 함수
변환(Transform) is 연산자 or 행렬연산 or 함수

모델 = 메쉬 (안바뀜)

게임오브젝트
메쉬의 포인터
위치정보를 가지고있는 클래스의
인스턴스

(피봇먼저)-S->R->T

카메라
세상을 바라보기위한 게임오브젝트 메쉬(X)
좌표, 회전, 

prosterm (절두체)사각뿔 중 너무 가까운것은 띄우지 않는다.

카메라 좌표변환 카메라의 월드좌표를 원점으로 바꾸기 위해
모든 오브젝트와 같이 움직여버린다.

실수3개 회전에서 짐벌락
실수9개(행렬) 에서는 문제가 생기지 않는다 
실수4개 쿼터니언

투영변환 알고리즘??

원근투영 나누기 연산
FOV가 90도 일때만
z = 1 인 평면에 투영시키는 것인가?
(x/z, y/z, z/z)

1. 3D -> 2D
2. |x/z, y/z| <= 1 만 그린다.
3. 원근감이 생긴다.
Z가 커지면 vanishing point 화면가운데의 점으로 표현되고
그것이 원근감을 만들어낸다.

FOV 를 줄이는것은 프레임rate를 줄이는데 도움이 된다.

-레이싱 게임-
FOV 를 작게 해야 속도감이 생긴다.
앞의 오브젝트가 계속 바뀌어야 한다.

-RPG게임-
FOV를 크게 하면 프레임이 낮아진다.

3D의 FOV는 사각뿔이므로 그려지는 오브젝트는
각도의 세제곱에 비례

직교투영은 카메라가 직육면체를 찍음

90도가 아닐때?? d = 5
x/(z/d), y/(z/d) 로 하면 공간을 키우는게 된다.

tanS = y/z
1 = y/z * 1/tanS
d = 1/tanS

View port 화면에 표시하기 위한 정보
원점과, 가로길이, 세로길이

매핑,변환 정사각형을 직사각형으로 변환
---------------------------------------------------
모델의 위치 방향 크기정보 (월드 변환)

가상의 카메라 (위치와 방향) 의 역변환
카메라 변환

FOV
투영변환 원근투영 나누기 연산이 가능한 조건?

Viewport 원점과 길이를 알면 화면좌표변환 가능

카메라와 점의 거리 d 가 크면 작게,대충(조명계산 할 필요?)
작으면 크게, 세밀하게(조명처리)
카메라와의 거리에 따라 디테일을 다르게 하는것 
Level of detail (프레임을 조절하는 가장 중요한 부분)

거리에 따라 Level을 나누고 가까이 있는것부터 처리를
줄여간다 Level 밖은 사진으로 대체(sky box)

3d 를 사진으로 줄인다던지, 3D처리의 폴리곤을 줄인다던지

레벨(거리)에 따른 메쉬를 구별하기 위해
배열을 사용할것인기, 링크드리스트를 사용할것인기,
이진트리를 사용할것인지, Search 어떤 탐색 알고리즘을 
이용할것인지. Search: 입력값을 주면 적당한 Output을 찾아내는것

조명 - 반사, 굴절, 그림자

벡터란?
벡터의 덧셈, 뺄셈, 스칼라 곱

벡터
1. 점 = 원점 + 벡터
2. 방향 = 크기와 방향? + 시작점?

요소별 연산 x,y,z 끼리끼리 연산

벡터의 스칼라 곱은 원래의 방향을 유지하거나 반대
방향이 다른방향으로 바뀌는 것은 덧셈

벡터의 정규화 단위벡터 크기가 1인벡터
방향을 나타내는 벡터 normal vector 법선벡터

벡터의 덧셈은 기하학적으로 이동의 수단

점의 연산(점끼리 빼면 벡터이기때문에 벡터의 뺄셈이라 칭함)
A-B = B->A
B-A = A->B
백터의 뺄셈은 이동의 방향을 얻는 수단

이동하는 과정을 보여주기 위해 이동속력이 필요
1.뺄셈의 값을 normalize = 법선벡터 
2.법선벡터 * 이동속도 가 이동벡터
3. 이동벡터를 현재위치에 더하면 이동

벡터의 외적 확인!!

1.clear
2.render
3.present(사용자에게 보여주기)

두 벡터는 비교할 수 없다.
두 점은 비교할 수 있다. 시작점이 원점으로 같기 때문에

외적 한 값(y)가 양수이면 +로 돌고, 음수이면 -로 돈다

내가 평면 앞에있으면 거리는 양수
내가 평면 뒤에있으면 거리는 음수
normal벡터의 방향

벡터의 평행이동 은 4X4 행렬로 한다.

왼손좌표계는 v * M
오른손좌표계는 M * v

0 0 0 a   x
0 0 0 b   y  로 곱했었다.
0 0 0 c   z
0 0 0 1

우리의 벡터는 x y z

연산의 방향도 다르다.
-> , <-

자전인경우에는 S R T 를 분리 가능하다.

벡터의 점과 방향

x, y, z, w 에서 - w 가 0일때는 평행이동이 적용되지 않는다. 
원점이 없는 연산. 

w = 1 은 점을 바꾸는 연산
w = 0 은 벡터를 바꾸는 연산 (평행이동의 정보가 없어진다.)

원점 + 방향 = 점
방향

원점에서 90도 회전하는 행렬
0 -1
1 0

원점에서 45도 회전하는 행렬
1/root2 -1/root2
1/root2 1/root2

축을 바꾼다. x 벡터와 y 벡터가 변하는것을 x y
				     x y 순으로 바꾼다.

축을 바꾸고 그린다. 축을 바꾸고 그린다.

x, y, z 벡터를 변환 
1 0 0 0
0 1 0 0
0 0 1 0
a b c 0

방향 1 0 0
원점 0 0 0

월드좌표계는 변하지 않는다.
모델좌표계는 변환에 의해 변한다.

카메라의 월드변환행렬 = 카메라의 월드좌표계

카메라 변환행렬 = (월드좌표계)게임세상의 모든 점들을 카메라좌표계로 바꾼는것 

x, y, z 가 직교하면 직교좌표계라 한다. 원들좌표계는 직교좌표계 
직교행렬의 역행렬은 전치행렬과 같다. 행과열을 바꾸기

true, false의 의미는같다.모뎅죄표계나 월드좌표계나

원근투영 나누기연산은 행렬로 표시가 불가능하다.
z/d 로 나누는것을 x,y 에 d 를 곱하는것으로 생각한다.

가로와 세로비는 종횡비

종횡비에 의해 변하는 화면만큼 미리 줄여놓자!

원근투영 나머지를
 UI는 직교투영


picking 화면좌표를 투영사각형의 좌표로 바꾸고 해당좌표의 직선 중
가장 앞에있는 점이 플레이어가 누를 점이다.
scaleing 을 이용하자
2가지의 scale 을 투영변환행렬이라 한다.

투영행렬을 역으로 카메라좌표계를 얻을 수 있다.

Depth는 z측의 길이가 아니다.
x,y,z,1 -> X/z,Y/z,Z/z,z    Z/z를 depth라 한다.
멀면 1 가까우면 0

DirectX 수학

동차좌표에서 w가 0이면 방향, 1이면 점

scale 을 쓰지않는 이유 곱셈연산을 해야한다.
변환을 위해서 단순 곱셈이 아니라 역행렬의 전치행렬을 구해야한다.

-9 
mtxRotation * m_mtxWorld = mtxRotation은 자전이다.

XMVECTOR, XMMATRIX 는 클래스변수로 쓰면 이상하다.
16-바이트 정렬로 컴파일러가 만들어 주지 않는다.

XMVECTOR는 구조체가 아니다. 128비트가 통째로 움직인다. 글로벌 operator
XMMATRIX는 구조체이다. 멤버변수 접근가능 struct의 멤버 operator

모델좌표계와 월드좌표계는 바뀌지 않는다. 

SRT -> 대부분의 함수는 이 앞에 붙인다. () SRT

함수의 끝에 est는 estimated 대충 계산해서 돌려준다

cood 와 normal 함수 x,y,z가 1 과 0

DirectX의 BooundingBox = AABB
단점: 바운딩박스의 크기가 계속 바뀐다. 계산이 계속 바뀐다.
Extent 는 대각선길이
BoundingOrientedBox = OOBB

Frustum 기울어진 6개의 면
구를 사용하는 충동검사가 제일 심플하고 빠르다

삼각형 충돌검사
disJoint, Intersect, Contain

삼각형-광선
거리-교점을 찾을 수 있게, 두개의 벡터로 반직선

삼각형-삼각형
시간이 아주 많이 걸린다
True - False

BoundingBox 의 센터가 바뀌는것 = 이동

방안을 평면6개, Boundingbox 두개중 하나로 표현 가능
contains나 intersects 함수중 골라서 실행

boundingBox transform 객체 행렬- 이동, 신축, 회전

BoundingFrustum 의 충돌체 = Projection
FOV가 90도가 아니고 z좌표를 원근투영 나누기를 하고
화면의 종횡비가 1:1이 아닐때의 표현 = Projection 행렬
대부분 카메라 절두체

Device

그래픽카드는 그림 잘그리는 도구, 프레임rate를 떨어뜨리지 않는 기능
GPU에서 실행되는 프로그램 - 쉐이더
Direct3D 라는 라이브러리를 활용해서 그래픽카드에서 쓰이는 
프로그램을 제작
하드웨어디바이스 -> 인캡슐레이션 -> 소프트웨어 디바이스(Device Context)
DLL(Dynamic Linked Library)
'동적' 링크드 라이브러리 - 컴파일때 넣지않고, 필요할 때만 갖다쓴다.
DLL은 코드가 다 있지만 Import Library는 함수의 존재와 몇번째라인에 있는지만
적어놓은 파일(DLL 의 MAP)

프로젝트 속성의 링커의 입력에 라이브러리 추가

수평스캔범위
모니터로 전송하는 속도
가로줄로 최대로 몇개 찍을 수 있는가

수직스캔범위
최대 몇 줄을 찍을 수 있는가
해상도는 한 프레임에 찍을 수 있는 픽셀의 수와, Hz를 나타낸다
60프레임이 일반적 그래픽카드와 모니터가 대부분 그렇다.

그래픽카드가 1초동안 보낼 수 있는 픽셀의 개수 BitRate

색상의 정규화, 모든 정보의 크기를 통일
0~1 사이의 실수로 표현
8bit, 16bit 가 되어도 0~1사이의 실수는 변하지 않는다.

게임프로그램 = CPU프로그램 + GPU프로그램
CPU bit수가 달라도 Direct3D가 normalize하고, GPU에 넘김

색상도 벡터이다. SIMD연산이 가능하다.
XMVECTOR -> 128비트로 변화!
011 100 은 서로 보색
내 게임에서 8비트색상을 쓸건지 32비트 색상을 쓸건지 결정하면 된다.

감마 부분은 스킵

프레임 버퍼 (출력할 그림을 담는 메모리)
CPU -> 프레임버퍼에 담는다 -> GPU -> 모니터가 읽어간다.
순서가 중요하다.

화면 깜빡임을 막기위해 2개 이상의 프레임버퍼를 만든다.
프레젠테이션 은 두가지 방법 블리트(느리다), 
플리핑or스왑(빠르다) - 전체화면 모드에서만 동작(해상도가 완벽하게 일치해야 한다.)

COM객체는 생성되어도 interface로 한번 포장되어 리턴된다
프로그램은 인터페이스 까지밖에 접근하지 못한다.

class는 구체적인 정보를 담고있다. 상속을 받을수록 많이 달라붙어서
많은 정보를 가지고, 차이가 있도록 만들어진다.
위로 올라갈수록 추상적이 된다. 일반적이 된다. 일.반.화

데이터가 없을 때까지 올라간다.
데이터가 없는 클래스 interface
함수의 body도 없고, 이름만 가지고 있다. 클래스를 극도로 추상화

인터페이스는 바뀔일이 없고, 노출할 함수만 노출할 수 있고, 객체를
숨길 수 있다. 한번 더 포장하는것
은닉화의 속성을 모두 가지고 있다.

Com의 최상 추상화클래스 IUnknown


__uuidof(인터페이스클래스이름) => GUID or REFID
다 외우기 힘들기때문에

스마트포인터?? Comptr

DXGI => 어탭터 = 인터페이스( 그래픽 카드를 나타낸다)

Factory(숫자는 버젼) 컴퓨터를 나타낸다
SwapChain은 후면버퍼, 전면버퍼는 접근 불가능
27, 37, 44, 77 페이지 외우기

IDXGIFactory 먼저

HRESULT 는 uint
HRESULT는 반드시 에러처리를 해야한다.

DESC 디스크립션 구조체
설명하는 구조체

Direct3D 디바이스는 상태기계이다.
모든 객체들이 state를 가지고 있다.

Lendering = state & draw
-> present
swap chain이 있어야 한다. (함수는 모조리 후면버퍼관련)
전면버퍼와 후면버퍼의 리스트

Setname 함수는 디버깅에서 유용하다.

D3D12 - 글로벌함수라는 표시

Adapter - D3D관점에서는 Device
DXGI 관점에서는 Adapter

그래픽카드 하드웨어를 만들때
D3D 어느버전까지 지원할 수 있는지 정한다.

WarpAdapter-윈도우가 지원하는 software adapter
FrameRate가 떨어질 수 있다.
그래픽카드가 D3D12를 부분적으로만 지원하고
나머지는 WARP로 소프트웨어적인 지원을 
받아서 구현이 가능할 수 있다.

COM Device ChildObject 를 만드는
Create...

D3D12 커맨트 큐를 만들면 swapchain을 만들 수 있다.

1. DXGI
2.D3D12 Device
3.swapchain
4.getBuffer

mode -> MODE(화면출력 해상도의 종류)였다.
지금은 후면버퍼의 출력형식

Usage
D3D는 cpu -> cpu가 gpu에 접근 관련

DXGI_RATIONAL 유리수 표현
분수를 표현하기 위함

UNSPECIFIED 를 사용하면 자동적으로 
PROGRESSIVE 하게 가장 알맞은

픽셀에 점을 찍으려면 픽셀의 형식을 알아야 한다.
133개의 format
TYPELESS는 정해놓지 않는것
32중 S8X24 24는 무시

다중 샘플링
샘플링( 픽셀 집합에서 원하는 픽셀을 가져옴)
필터링( 픽셀들로 연산[거른다], 평균)

SuperSampling 4배 크게 그린다. 픽셀4배X 픽셀4개O
4개를 하나로 만든다.랜더링 시간이 4배
그래픽 XX?가 지원을 해야한다 라이브러리? 카드?

MultiSampling 


enumeration
은 꼭 그 데이터 타입이어야 하지만

UINT는 그렇지 않다.
or 로 여러개의 옵션을 지정 할 수 있다.































