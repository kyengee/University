중간고사: 4월 마지막 5월 초
3월 29(금) 9-10교시
4월 1일 11-12교시
4월 5일 10-11교시
5월 9일 수업없음
중간고사 : 5월 16일 14:50

4월 18 22 25 수업없음
29일 부터 시험시작

게임프로그래밍은 일반적인 프로그래밍(문제가 주어지는)과 달리
문제를 만들어내고 문제를 규정하는데 이 과정을 게임기획이라고 한다.

내부의 데이터의 표현이 3D인지 2D인지에 따라 
3D게임인지 2D게임인지가 나뉜다.

데이터도3D 구현(화면출력)도 3D처리를 하면 3D게임이라고 할 수 있다.

-수업내용-
T&L
Transform 선형대수학 이동변환(atem?어템포), 신축-회전(선형변환)
Lighting 변환된것을 화면에 표현하는것.

변환을 위한 수학= 벡터,행렬

GameFramework 게임의 골격을 만들어본다.

Shader Programming GPU를 사용하기 위해
--------------------------
게임에는 여러가지 처리과정이 있다.
과정중 화면에 그리기위한 과정을 렌더링이라하고
3차원 -> 2차원
처리를 해주는 엔진을 렌더링 엔진, 그래픽스 엔진이라 한다.
(컴퓨터를 이용하기때문에 수학적인 방법을 이용해야한다.)

기하학적 모델링
메쉬-다각형의집합-삼각형의집합-선분들의집합-점(벡터)들의집합
-실수들의 집합
렌더링은 선분을 그리는것이 아니라 면을 그리는 것(색)
입체의 기본단위는 육면체
입체중 그릴범위를 판단하는것도 벡터와 행렬을 사용하여한다

원은 3개의 실수로 그릴 수 있지만 3D모델은 그렇지 않기때문에
점들의 집합으로 나타내었고 이것을 표현하는걸 기하학적 모델링이라고
한다.

2차원에서의 기하학
좌표계
화면좌표계는 직교좌표계와는 달리 정수만 사용한다(픽셀의 위치를 나타내기 때문)
화면좌표계는 2D이지만 게임상에서는 직교 3차원 좌표계
다이렉트X는 왼손좌표계 Opengl은 오른손좌표계

왼손좌표계 x,y,z가 시계방향, 오른손좌표계 x,y,z가 반시계방향
왼손은 멀리 떨어져있는(z)가 수가 크다.

3차원의 좌표를 표현하려면 최소 3개의 벡터가 필요하다.
세개의 기저벡터(스칼라곱과 덧셈) (1,0,0), (0,1,0), (0,0,1)의 선형결합으로
스칼라곱과 덧셈으로 정의할수 있는 어떤것 = 벡터

메쉬 - 다각형들의집합 - 점들의 집합 - 순서쌍들의 집합
struct{ x, y, z} -> 순서쌍

오브젝트의 위치와 방향이 바뀌는것 - 애니메이션
큐브의 회전, 위치이동(Transform)

위치와 방향을 바꾸기위한 프로그램을 만드는것

모델을 표현
모델을 표현하기위한 좌표계 - 모델좌표계
게임세상을 표현하기위한 좌표계 - 월드좌표계 - 딱 하나 존재

메쉬와 모델의 원점은 같을 필요는 없지만 같으면 좋다.

모델, 위치, 방향 - 메쉬를 표현하기 위한 3가지

메쉬와 텍스쳐매핑

원기둥을 무한대의 폴리곤으로 나타낼수 없기때문에 수를 제한하고,
그 폴리곤들에 텍스쳐를 '매핑'
(Map = 2D이미지)
Height Map 높이를 2D로
Bump Map 표면의 요철을 표현

1. Batch
OverHead 를 줄이기 위해 일괄처리

2. 미리 계산
정적(static)인 것들을 미리계산

게임의 1순위 Frame Rate

다각형 와인딩 순서
FrontFace 화면에 보이는 면
BackFace 화면에 보이지 않는 면(은면)
culling - 처리계산에서 뺀다.

polyGon 표현을 위해서 정점을 나열해야 한다. 시계방향
Winding Order 시계방향(보이는면), 반시계방향(안보이는면)
항상 보일때를 기준으로 해서 시계방향

Scene(게임월드자체 하나!) 을 표현할때 같은 렌더링을 사용한다.
Scene = 게임오브젝트의 배열
게임오브젝트를 그린다-> 모델을 그린다->polygon을 그린다
다각형-> 픽셀로 변환(transform) -> 픽셀들의 집합
픽셀들의 색을 결정-Lighting

픽셀을 어떻게 찾아낼것인지
렌더링(T&L 중 T)
변환 파이프라인(transform 과정)
투영변환 n차원 -> n-1차원 (원근 알고리즘 필요)
모델의 점을 화면에 표시되기까지의 변화과정

Primitives = Polygon
이동 -> 위치
회전 -> 방향

함수= 변환의 한 예
x 와 y 집합의 상관관계f 에 대해 x의 결과값이 하나만 나오는 경우 함수
변환(Transform) is 연산자 or 행렬연산 or 함수

모델 = 메쉬 (안바뀜)

게임오브젝트
메쉬의 포인터
위치정보를 가지고있는 클래스의
인스턴스

(피봇먼저)-S->R->T

카메라
세상을 바라보기위한 게임오브젝트 메쉬(X)
좌표, 회전, 

prosterm (절두체)사각뿔 중 너무 가까운것은 띄우지 않는다.

카메라 좌표변환 카메라의 월드좌표를 원점으로 바꾸기 위해
모든 오브젝트와 같이 움직여버린다.

실수3개 회전에서 짐벌락
실수9개(행렬) 에서는 문제가 생기지 않는다 
실수4개 쿼터니언

투영변환 알고리즘??

원근투영 나누기 연산
FOV가 90도 일때만
z = 1 인 평면에 투영시키는 것인가?
(x/z, y/z, z/z)

1. 3D -> 2D
2. |x/z, y/z| <= 1 만 그린다.
3. 원근감이 생긴다.
Z가 커지면 vanishing point 화면가운데의 점으로 표현되고
그것이 원근감을 만들어낸다.

FOV 를 줄이는것은 프레임rate를 줄이는데 도움이 된다.

-레이싱 게임-
FOV 를 작게 해야 속도감이 생긴다.
앞의 오브젝트가 계속 바뀌어야 한다.

-RPG게임-
FOV를 크게 하면 프레임이 낮아진다.

3D의 FOV는 사각뿔이므로 그려지는 오브젝트는
각도의 세제곱에 비례

직교투영은 카메라가 직육면체를 찍음

90도가 아닐때?? d = 5
x/(z/d), y/(z/d) 로 하면 공간을 키우는게 된다.

tanS = y/z
1 = y/z * 1/tanS
d = 1/tanS

View port 화면에 표시하기 위한 정보
원점과, 가로길이, 세로길이

매핑,변환 정사각형을 직사각형으로 변환
---------------------------------------------------
모델의 위치 방향 크기정보 (월드 변환)

가상의 카메라 (위치와 방향) 의 역변환
카메라 변환

FOV
투영변환 원근투영 나누기 연산이 가능한 조건?

Viewport 원점과 길이를 알면 화면좌표변환 가능

카메라와 점의 거리 d 가 크면 작게,대충(조명계산 할 필요?)
작으면 크게, 세밀하게(조명처리)
카메라와의 거리에 따라 디테일을 다르게 하는것 
Level of detail (프레임을 조절하는 가장 중요한 부분)

거리에 따라 Level을 나누고 가까이 있는것부터 처리를
줄여간다 Level 밖은 사진으로 대체(sky box)

3d 를 사진으로 줄인다던지, 3D처리의 폴리곤을 줄인다던지

레벨(거리)에 따른 메쉬를 구별하기 위해
배열을 사용할것인기, 링크드리스트를 사용할것인기,
이진트리를 사용할것인지, Search 어떤 탐색 알고리즘을 
이용할것인지. Search: 입력값을 주면 적당한 Output을 찾아내는것

조명 - 반사, 굴절, 그림자

벡터란?
벡터의 덧셈, 뺄셈, 스칼라 곱

벡터
1. 점 = 원점 + 벡터
2. 방향 = 크기와 방향? + 시작점?

요소별 연산 x,y,z 끼리끼리 연산

벡터의 스칼라 곱은 원래의 방향을 유지하거나 반대
방향이 다른방향으로 바뀌는 것은 덧셈

벡터의 정규화 단위벡터 크기가 1인벡터
방향을 나타내는 벡터 normal vector 법선벡터

벡터의 덧셈은 기하학적으로 이동의 수단

점의 연산(점끼리 빼면 벡터이기때문에 벡터의 뺄셈이라 칭함)
A-B = B->A
B-A = A->B
백터의 뺄셈은 이동의 방향을 얻는 수단

이동하는 과정을 보여주기 위해 이동속력이 필요
1.뺄셈의 값을 normalize = 법선벡터 
2.법선벡터 * 이동속도 가 이동벡터
3. 이동벡터를 현재위치에 더하면 이동

벡터의 외적 확인!!

1.clear
2.render
3.present(사용자에게 보여주기)

두 벡터는 비교할 수 없다.
두 점은 비교할 수 있다. 시작점이 원점으로 같기 때문에

외적 한 값(y)가 양수이면 +로 돌고, 음수이면 -로 돈다

내가 평면 앞에있으면 거리는 양수
내가 평면 뒤에있으면 거리는 음수
normal벡터의 방향

벡터의 평행이동 은 4X4 행렬로 한다.

왼손좌표계는 v * M
오른손좌표계는 M * v

0 0 0 a   x
0 0 0 b   y  로 곱했었다.
0 0 0 c   z
0 0 0 1

우리의 벡터는 x y z

연산의 방향도 다르다.
-> , <-

자전인경우에는 S R T 를 분리 가능하다.

벡터의 점과 방향

x, y, z, w 에서 - w 가 0일때는 평행이동이 적용되지 않는다. 
원점이 없는 연산. 

w = 1 은 점을 바꾸는 연산
w = 0 은 벡터를 바꾸는 연산 (평행이동의 정보가 없어진다.)

원점 + 방향 = 점
방향

원점에서 90도 회전하는 행렬
0 -1
1 0

원점에서 45도 회전하는 행렬
1/root2 -1/root2
1/root2 1/root2

축을 바꾼다. x 벡터와 y 벡터가 변하는것을 x y
				     x y 순으로 바꾼다.

축을 바꾸고 그린다. 축을 바꾸고 그린다.

x, y, z 벡터를 변환 
1 0 0 0
0 1 0 0
0 0 1 0
a b c 0

방향 1 0 0
원점 0 0 0

월드좌표계는 변하지 않는다.
모델좌표계는 변환에 의해 변한다.

카메라의 월드변환행렬 = 카메라의 월드좌표계

카메라 변환행렬 = (월드좌표계)게임세상의 모든 점들을 카메라좌표계로 바꾼는것 

x, y, z 가 직교하면 직교좌표계라 한다. 원들좌표계는 직교좌표계 
직교행렬의 역행렬은 전치행렬과 같다. 행과열을 바꾸기

true, false의 의미는같다.모뎅죄표계나 월드좌표계나

원근투영 나누기연산은 행렬로 표시가 불가능하다.
z/d 로 나누는것을 x,y 에 d 를 곱하는것으로 생각한다.

가로와 세로비는 종횡비

종횡비에 의해 변하는 화면만큼 미리 줄여놓자!

원근투영 나머지를
 UI는 직교투영

picking 화면좌표를 투영사각형의 좌표로 바꾸고 해당좌표의 직선 중
가장 앞에있는 점이 플레이어가 누를 점이다.
scaleing 을 이용하자
2가지의 scale 을 투영변환행렬이라 한다.

투영행렬을 역으로 카메라좌표계를 얻을 수 있다.

Depth는 z측의 길이가 아니다.
x,y,z,1 -> X/z,Y/z,Z/z,z    Z/z를 depth라 한다.
멀면 1 가까우면 0

DirectX 수학

동차좌표에서 w가 0이면 방향, 1이면 점

scale 을 쓰지않는 이유 곱셈연산을 해야한다.
변환을 위해서 단순 곱셈이 아니라 역행렬의 전치행렬을 구해야한다.

-9 
mtxRotation * m_mtxWorld = mtxRotation은 자전이다.

XMVECTOR, XMMATRIX 는 클래스변수로 쓰면 이상하다.
16-바이트 정렬로 컴파일러가 만들어 주지 않는다.

XMVECTOR는 구조체가 아니다. 128비트가 통째로 움직인다. 글로벌 operator
XMMATRIX는 구조체이다. 멤버변수 접근가능 struct의 멤버 operator

모델좌표계와 월드좌표계는 바뀌지 않는다. 

SRT -> 대부분의 함수는 이 앞에 붙인다. () SRT

함수의 끝에 est는 estimated 대충 계산해서 돌려준다

cood 와 normal 함수 x,y,z가 1 과 0

DirectX의 BooundingBox = AABB
단점: 바운딩박스의 크기가 계속 바뀐다. 계산이 계속 바뀐다.
Extent 는 대각선길이
BoundingOrientedBox = OOBB

Frustum 기울어진 6개의 면
구를 사용하는 충동검사가 제일 심플하고 빠르다

삼각형 충돌검사
disJoint, Intersect, Contain

삼각형-광선
거리-교점을 찾을 수 있게, 두개의 벡터로 반직선

삼각형-삼각형
시간이 아주 많이 걸린다
True - False

BoundingBox 의 센터가 바뀌는것 = 이동

방안을 평면6개, Boundingbox 두개중 하나로 표현 가능
contains나 intersects 함수중 골라서 실행

boundingBox transform 객체 행렬- 이동, 신축, 회전

BoundingFrustum 의 충돌체 = Projection
FOV가 90도가 아니고 z좌표를 원근투영 나누기를 하고
화면의 종횡비가 1:1이 아닐때의 표현 = Projection 행렬
대부분 카메라 절두체

Device

그래픽카드는 그림 잘그리는 도구, 프레임rate를 떨어뜨리지 않는 기능
GPU에서 실행되는 프로그램 - 쉐이더
Direct3D 라는 라이브러리를 활용해서 그래픽카드에서 쓰이는 
프로그램을 제작
하드웨어디바이스 -> 인캡슐레이션 -> 소프트웨어 디바이스(Device Context)
DLL(Dynamic Linked Library)
'동적' 링크드 라이브러리 - 컴파일때 넣지않고, 필요할 때만 갖다쓴다.
DLL은 코드가 다 있지만 Import Library는 함수의 존재와 몇번째라인에 있는지만
적어놓은 파일(DLL 의 MAP)

프로젝트 속성의 링커의 입력에 라이브러리 추가

수평스캔범위
모니터로 전송하는 속도
가로줄로 최대로 몇개 찍을 수 있는가

수직스캔범위
최대 몇 줄을 찍을 수 있는가
해상도는 한 프레임에 찍을 수 있는 픽셀의 수와, Hz를 나타낸다
60프레임이 일반적 그래픽카드와 모니터가 대부분 그렇다.

그래픽카드가 1초동안 보낼 수 있는 픽셀의 개수 BitRate

색상의 정규화, 모든 정보의 크기를 통일
0~1 사이의 실수로 표현
8bit, 16bit 가 되어도 0~1사이의 실수는 변하지 않는다.

게임프로그램 = CPU프로그램 + GPU프로그램
CPU bit수가 달라도 Direct3D가 normalize하고, GPU에 넘김

색상도 벡터이다. SIMD연산이 가능하다.
XMVECTOR -> 128비트로 변화!
011 100 은 서로 보색
내 게임에서 8비트색상을 쓸건지 32비트 색상을 쓸건지 결정하면 된다.

감마 부분은 스킵

프레임 버퍼 (출력할 그림을 담는 메모리)
CPU -> 프레임버퍼에 담는다 -> GPU -> 모니터가 읽어간다.
순서가 중요하다.

화면 깜빡임을 막기위해 2개 이상의 프레임버퍼를 만든다.
프레젠테이션 은 두가지 방법 블리트(느리다), 
플리핑or스왑(빠르다) - 전체화면 모드에서만 동작(해상도가 완벽하게 일치해야 한다.)

COM객체는 생성되어도 interface로 한번 포장되어 리턴된다
프로그램은 인터페이스 까지밖에 접근하지 못한다.

class는 구체적인 정보를 담고있다. 상속을 받을수록 많이 달라붙어서
많은 정보를 가지고, 차이가 있도록 만들어진다.
위로 올라갈수록 추상적이 된다. 일반적이 된다. 일.반.화

데이터가 없을 때까지 올라간다.
데이터가 없는 클래스 interface
함수의 body도 없고, 이름만 가지고 있다. 클래스를 극도로 추상화

인터페이스는 바뀔일이 없고, 노출할 함수만 노출할 수 있고, 객체를
숨길 수 있다. 한번 더 포장하는것
은닉화의 속성을 모두 가지고 있다.

Com의 최상 추상화클래스 IUnknown


__uuidof(인터페이스클래스이름) => GUID or REFID
다 외우기 힘들기때문에

스마트포인터?? Comptr

DXGI => 어탭터 = 인터페이스( 그래픽 카드를 나타낸다)

Factory(숫자는 버젼) 컴퓨터를 나타낸다
SwapChain은 후면버퍼, 전면버퍼는 접근 불가능
27, 37, 44, 77 페이지 외우기

IDXGIFactory 먼저

HRESULT 는 uint
HRESULT는 반드시 에러처리를 해야한다.

DESC 디스크립션 구조체
설명하는 구조체

Direct3D 디바이스는 상태기계이다.
모든 객체들이 state를 가지고 있다.

Lendering = state & draw
-> present
swap chain이 있어야 한다. (함수는 모조리 후면버퍼관련)
전면버퍼와 후면버퍼의 리스트

Setname 함수는 디버깅에서 유용하다.

D3D12 - 글로벌함수라는 표시

Adapter - D3D관점에서는 Device
DXGI 관점에서는 Adapter

그래픽카드 하드웨어를 만들때
D3D 어느버전까지 지원할 수 있는지 정한다.

WarpAdapter-윈도우가 지원하는 software adapter
FrameRate가 떨어질 수 있다.
그래픽카드가 D3D12를 부분적으로만 지원하고
나머지는 WARP로 소프트웨어적인 지원을 
받아서 구현이 가능할 수 있다.

COM Device ChildObject 를 만드는
Create...

D3D12 커맨트 큐를 만들면 swapchain을 만들 수 있다.

1. DXGI
2.D3D12 Device
3.swapchain
4.getBuffer

mode -> MODE(화면출력 해상도의 종류)였다.
지금은 후면버퍼의 출력형식

Usage
D3D는 cpu -> cpu가 gpu에 접근 관련

DXGI_RATIONAL 유리수 표현
분수를 표현하기 위함

UNSPECIFIED 를 사용하면 자동적으로 
PROGRESSIVE 하게 가장 알맞은

픽셀에 점을 찍으려면 픽셀의 형식을 알아야 한다.
133개의 format
TYPELESS는 정해놓지 않는것
32중 S8X24 24는 무시

다중 샘플링
샘플링( 픽셀 집합에서 원하는 픽셀을 가져옴)
필터링( 픽셀들로 연산[거른다], 평균)

SuperSampling 4배 크게 그린다. 픽셀4배X 픽셀4개O
4개를 하나로 만든다.랜더링 시간이 4배
그래픽 XX?가 지원을 해야한다 라이브러리? 카드?

MultiSampling 


enumeration
은 꼭 그 데이터 타입이어야 하지만

UINT는 그렇지 않다.
or 로 여러개의 옵션을 지정 할 수 있다.

Resize Target - 윈도우모드일때 윈도우의 크기를 변경
전체화면일때 컴퓨터의 해상도를 변경

DXGI_SWAP_CHAIN_FLAG
의 DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH
필요

DXGI의 후면버퍼 = D3D RenderTarget
비디오메모리를 나타내는 인터페이스 = ID3D12Resource
Texture도 있을 수 있음

UINT 는 oring 가능

수직회귀 - 모니터가 전면버퍼의 데이터를 모두 출력할때
이때 present 하면 좋다

플립모델은 참고

클라이언트의 윈도우크기가 바뀌면 wn_size메세지 발생

윈도우크기가 바뀌면 버퍼를 바꾸는것이 아니라
전체화면에 갈때 후면버퍼의 크기는 안바뀌고 바탕화면의 크기를 바꾼다.

명령큐, 명령 리스트
ExecuteCommandList -> 실행이 아니라 Push

Set&Draw

큐가 있지않은 Resource는 cpu와 gpu간의 동기화가 필요하다.

offline - Frame에 구애받지 않는
D3D 디바이스의 멤버함수를 사용하는 영역
create()

online - Frame(): Set&Draw
사용자 입력처리, 애니메이션, 렌더

CPU/GPU 동기화

명령리스트 - 동적배열(배치처리를 위해 존재-한번에 실행되어야할것들)
두가지 상태
open - 명령 추가가능
close - 명령 추가 불가능 -> 커맨드큐에 추가가능
Reset은 재활용을 위한 초기화

명령을 만드는건 cpu
실행은 gpu
동기화 - 딜레이

동기화를 위한 펜스 오브젝트
사용을위해 Event를 사용 (윈도우에서 제공하는 동기화함수)

커맨트큐의 signal함수 펜스에 값을 집어넣어라
펜스의 signal함수 

WaitForSingleObject 이벤트를 기다리는 운영체제의 함수

쉐이더 - gpu가 렌더링을 하기위한 프로그램
리소스는 쉐이더가 쓰는것

리소스 - 그림데이터와 그림이 아닌 데이터
그림데이터 Texture 배열의 원소가 픽셀의 색을 나타냄
그림이 아닌 데이터 버퍼 - 배열의 원소가 실수값인것

그래픽스 파이프라인 - 변환
계산 파이프라인 - 병렬처리로 수학적 연산

쉐이더는 리소스 뷰로 접근
뷰 : 리소스를 어떤 목적으로 사용할것인지
뷰는 데이터를 설명하는 자료구조
크기, format

리소스 -> 뷰를 만든다 -> gpu에게 setView

Descriptor = View

-------------리 소 스-----------------------

이미지는 2의거듭제곱 형태가 가장 효율적이다.
메모리의 시작주소도 마찬가지
하드웨어적으로 빠른 처리를 할 수 있다.
전체의 이미지- 텍스쳐(밉맵들의 집합)
MipmapLevel - 이미지를 2로 나누면서
레벨을 증가시켜간다. 마지막 1픽셀까지 줄여나간다.

PlacedResource, ReservedResource 안쓰고
commitedResourse를 사용한다 자동으로 생성다해준다
뭘 해주는지를 알자

Direct3D 파이프라인에 view를 연결
GraphicsCommandList::OMSetRenderTargets
OM = OutputMarjor
동시에 여러개 set가능(D3D12는 최대 8개)
Depth NULL or 값

clearRenderTargetView 
view를 지우는게 아니라 뷰를 이용해 리소스를 지우는것

CPU -> GPU 의 버스를통한 통신을
최대로 줄이는것도 관건. 그래서 한번에 여러개 의 갯수를
수정할 수 있게 함

Depth는 처음이 1
Depth버퍼 알고리즘은 0.5를 기준으로 비교를 한다.

모든 세계를 그리고 Depth를 클리어하고 캐릭터를 그리면
Depth에 관계없이 캐릭터는 항상 보이게 된다.

원래대로라면 벽 뒤에있으면 그리지 않는다.

RS RasterizerStage 는 OM 이전에 수행된다.

graphics pipeline 그림을 위한
compute pipeline 계산을 위한

---------------Graphics Pipeline---------------------

파이프라인 - Draw함수를 의미한다

고정프로그램 단계에서는 파라미터값만 변경 가능하다.
Set함수를 호출하여 바꿀 수 있다. (전에 나왔던 함수들)
프로그램 가능단계는 자신의 함수를 만들어서 연결한다.

DirectX 9 와 10은 기하쉐이더 추가도 달라졌다.
테셀레이션이 핵심이다

Primitive 점,선분,삼각형이 될 수 있다.
중에 무엇인가는 tocoloze

두개의 버퍼를 합친것을 모델이라 하자

쉐이더 언어의 시멘틱 float4 a: 시멘틱
꼬리표를 만들 수 있다.

IA -> VS
SV_PrimitiveID -> 0
SV_VertexID -> 0
SV_VertexID -> 1
SV_VertexID -> 2
SV_PrimitiveID -> 1
SV_VertexID -> 0
SV_VertexID -> 1
SV_VertexID -> 2
순서로.. 쉐이더가 이 변수를 쓰는지는 자기 맘

RS
벡터정보를 레스터이미지(픽셀들의 집합으로 그림을 그리는 것
)로 바꾸는 과정
-스크린 좌표 변환-
월드변환,카메라변환,원근투영행렬곱하기->원근투영나누기(Z)2D
스크린좌표계-픽셀
클리핑(그리지 않는 점들을 찾는다)

1학기때는

IA(모델좌표계) - VS(투영좌표계) - RS - PS - OM
PS = FragmentShader

모델좌표계의 정점과 월드좌표의 정점은 다르다
그래서 RS단계의 두가지 역할의 두번째
Interpolation 없던값까지 만들어서 주는것

OM
블렌딩
기존의 화면과 섞는다

byte코드 - 일종의 가상코드



D3DCompileFromFile()
버전 _5_1 까지는 지원한다.

RS 그림자는 건너뛰기

픽셀이 된 순간 - 렌더타겟의 화면좌표계 혹은 스크린좌표계

42p 는 배치처리를 하지 못한다
그래서 44p 의 쉐이더 객체가 그리는 방식까지 저장해논다.
42p 는 그리고, set하고 그리고 set하고
44p는 set하고 그~~리고, set하고 그~~리고

--------------Pipeline2-------------------

리소스 - 버퍼, 리소스
버퍼 - 버퍼, 콘스탄트버퍼(그림데이터는 아니야[한프레임동안은 상수])
정점버퍼, 인덱스버퍼 - 기하학적인 데이터표현을 위함

비디오메모리 - 속도가 느린 경로를 통해서 SET들이 실행
그래서 SET을 줄여야함
36p로 건너뜀


39p
TRIANGLESTRIP 까지만 보자
TRIANGLESTRIP 은 전면,은면,전면이 되어야하지만
내부적으로 모두다 전면으로 바꿈
정점을 아래,위,아래,위 로 주면 모두 그릴 수 있다.

42p 위는 3개씩 파이프라인을 흘려보내서
불필요한 연산이 여러번 반복된다.

아래는 파이프라인을 한번에
정점데이터와 인덱스데이터
인덱스 버퍼를 더 사용하지만 그래도 위보다는 
메모리를 적게 사용한다.

쉐이더에 Input을 제외한 변수는 전역변수를 통해 전달한다.

Signature - 서명
오버로딩된 함수를 구별하는(type, 파라미터의 개수)
in C++ no C

루트시그너쳐 루트파라미터
파이프라인 전체를 함수라했을때 파라미터값
-쉐이더가 선언한 글로벌 변수-

func(int a) a - 파라미터
func(3) 3 - 아규먼트

int a, int *p, int **pp 까지만 수용하겠다.
리소스 설명 - 디스크립터

루트상수 - 루트서술자 - 서술자테이블 순 순서

변수선언해도 메모리는 할당되지 않는다.
변수를 리소스로 설정하는 절차는 d3d12로 create resource
해야한다.

constant를 제외하고는 리소스를 다 할당해주어야 한다.


---------------------------HLSL------------------------

재귀함수 X, 포인터 없음, 동적메모리할당 X
전역변수는 변수 선언에 메모리할당 X, D3Dx로 create 해야함

+연산자는, 숫자, 행렬, 벡터 다 가능 (대부분의 연산자는 요소별 연산)
c++처럼 float4 v = float4(1,1,1,1) 가능
%가 정수와 실수도 가능

전역변수를 default로 extern

static은 자기파일안에서만 쓰겠다는 뜻
static은 변수를 할당하는 순간 메모리가 할당이 됨
쉐이더 안에서만 쓰겠다는것으로 외부에서 메모리할당 못함.
static은 운영체제에서 접근못함. 쉐이더안에서만 씀

운영체제에서 가져가야하는데 const면 안되기 때문에
const 는 기본적으로 static일때 쓴다. 

기본 열우선행렬로 저장
열우선이 벡터와의 연산때 쉽다.

상수버퍼 최대크기 4K벡터만 가능
float2 가 첫번째벡터의마지막,두번째벡터의처음이 되면 허용하지 않는다.

팩킹된 쉐이더 상수 버퍼와 응용 프로그램의 메모리구조가 다를 수 있다.
상수버퍼의 빈 부분을 넘어갈때 잘못되면 잘못 넘어갈 수 있다.
그래서 2,4,2 일때 2,2(dumy),4,2로 하던가 packoffset을 쓰던가

상수버퍼는 c와 다르게 빈공간이 생길 수 있다.

struct는 무조건 새로운 레지스터의 시작

벡터 데이터형
Swizzling 가능
Masking 가능 하지만 xx는 안됨

행렬도 마찬가지

--------------terrian---------------

직선의 linierinterpolation 은 해당좌표의 픽셀을 의미
이미지 = 함수

중간고사 20일 17:40

1 소프트웨어 렌더러
2. D3D로 만들고 주변에 오브젝트로 속도감 조성
3. 지형, 철로, 다리 ( 움직이는 방향에 생성) 26일까지

















