중간고사: 4월 마지막 5월 초
3월 29(금) 9-10교시
4월 1일 11-12교시
4월 5일 10-11교시

게임프로그래밍은 일반적인 프로그래밍(문제가 주어지는)과 달리
문제를 만들어내고 문제를 규정하는데 이 과정을 게임기획이라고 한다.

내부의 데이터의 표현이 3D인지 2D인지에 따라 
3D게임인지 2D게임인지가 나뉜다.

데이터도3D 구현(화면출력)도 3D처리를 하면 3D게임이라고 할 수 있다.

-수업내용-
T&L
Transform 선형대수학 이동변환(atem?어템포), 신축-회전(선형변환)
Lighting 변환된것을 화면에 표현하는것.

변환을 위한 수학= 벡터,행렬

GameFramework 게임의 골격을 만들어본다.

Shader Programming GPU를 사용하기 위해
--------------------------
게임에는 여러가지 처리과정이 있다.
과정중 화면에 그리기위한 과정을 렌더링이라하고
3차원 -> 2차원
처리를 해주는 엔진을 렌더링 엔진, 그래픽스 엔진이라 한다.
(컴퓨터를 이용하기때문에 수학적인 방법을 이용해야한다.)

기하학적 모델링
메쉬-다각형의집합-삼각형의집합-선분들의집합-점(벡터)들의집합
-실수들의 집합
렌더링은 선분을 그리는것이 아니라 면을 그리는 것(색)
입체의 기본단위는 육면체
입체중 그릴범위를 판단하는것도 벡터와 행렬을 사용하여한다

원은 3개의 실수로 그릴 수 있지만 3D모델은 그렇지 않기때문에
점들의 집합으로 나타내었고 이것을 표현하는걸 기하학적 모델링이라고
한다.

2차원에서의 기하학
좌표계
화면좌표계는 직교좌표계와는 달리 정수만 사용한다(픽셀의 위치를 나타내기 때문)
화면좌표계는 2D이지만 게임상에서는 직교 3차원 좌표계
다이렉트X는 왼손좌표계 Opengl은 오른손좌표계

왼손좌표계 x,y,z가 시계방향, 오른손좌표계 x,y,z가 반시계방향
왼손은 멀리 떨어져있는(z)가 수가 크다.

3차원의 좌표를 표현하려면 최소 3개의 벡터가 필요하다.
세개의 기저벡터(스칼라곱과 덧셈) (1,0,0), (0,1,0), (0,0,1)의 선형결합으로
스칼라곱과 덧셈으로 정의할수 있는 어떤것 = 벡터

메쉬 - 다각형들의집합 - 점들의 집합 - 순서쌍들의 집합
struct{ x, y, z} -> 순서쌍

오브젝트의 위치와 방향이 바뀌는것 - 애니메이션
큐브의 회전, 위치이동(Transform)

위치와 방향을 바꾸기위한 프로그램을 만드는것

모델을 표현
모델을 표현하기위한 좌표계 - 모델좌표계
게임세상을 표현하기위한 좌표계 - 월드좌표계 - 딱 하나 존재

메쉬와 모델의 원점은 같을 필요는 없지만 같으면 좋다.

모델, 위치, 방향 - 메쉬를 표현하기 위한 3가지

메쉬와 텍스쳐매핑

원기둥을 무한대의 폴리곤으로 나타낼수 없기때문에 수를 제한하고,
그 폴리곤들에 텍스쳐를 '매핑'
(Map = 2D이미지)
Height Map 높이를 2D로
Bump Map 표면의 요철을 표현

1. Batch
OverHead 를 줄이기 위해 일괄처리

2. 미리 계산
정적(static)인 것들을 미리계산

게임의 1순위 Frame Rate

다각형 와인딩 순서
FrontFace 화면에 보이는 면
BackFace 화면에 보이지 않는 면(은면)
culling - 처리계산에서 뺀다.

polyGon 표현을 위해서 정점을 나열해야 한다. 시계방향
Winding Order 시계방향(보이는면), 반시계방향(안보이는면)
항상 보일때를 기준으로 해서 시계방향

Scene(게임월드자체 하나!) 을 표현할때 같은 렌더링을 사용한다.
Scene = 게임오브젝트의 배열
게임오브젝트를 그린다-> 모델을 그린다->polygon을 그린다
다각형-> 픽셀로 변환(transform) -> 픽셀들의 집합
픽셀들의 색을 결정-Lighting

픽셀을 어떻게 찾아낼것인지
렌더링(T&L 중 T)
변환 파이프라인(transform 과정)
투영변환 n차원 -> n-1차원 (원근 알고리즘 필요)
모델의 점을 화면에 표시되기까지의 변화과정

Primitives = Polygon
이동 -> 위치
회전 -> 방향

함수= 변환의 한 예
x 와 y 집합의 상관관계f 에 대해 x의 결과값이 하나만 나오는 경우 함수
변환(Transform) is 연산자 or 행렬연산 or 함수

모델 = 메쉬 (안바뀜)

게임오브젝트
메쉬의 포인터
위치정보를 가지고있는 클래스의
인스턴스

(피봇먼저)-S->R->T

카메라
세상을 바라보기위한 게임오브젝트 메쉬(X)
좌표, 회전, 

prosterm (절두체)사각뿔 중 너무 가까운것은 띄우지 않는다.

카메라 좌표변환 카메라의 월드좌표를 원점으로 바꾸기 위해
모든 오브젝트와 같이 움직여버린다.

평행이동 먼저, 회전 그 다음

실수3개 회전에서 짐벌란??
실수9개(행렬) 에서는 문제가 생기지 않는다 
실수4개 쿼터니언

투영변환 알고리즘??

원근투영 나누기 연산
FOV가 90도 일때만
z = 1 인 평면에 투영시키는 것인가?
(x/z, y/z, z/z)

1. 3D -> 2D
2. |x/z, y/z| <= 1 만 그린다.
3. 원근감이 생긴다.
Z가 커지면 vanishing point 화면가운데의 점으로 표현되고
그것이 원근감을 만들어낸다.

FOV 를 줄이는것은 프레임rate를 줄이는데 도움이 된다.

-레이싱 게임-
FOV 를 작게 해야 속도감이 생긴다.
앞의 오브젝트가 계속 바뀌어야 한다.

-RPG게임-
FOV를 크게 하면 프레임이 낮아진다.

3D의 FOV는 사각뿔이므로 그려지는 오브젝트는
각도의 세제곱에 비례

직교투영은 카메라가 직육면체를 찍음

90도가 아닐때?? d = 5
x/(z/d), y/(z/d) 로 하면 공간을 키우는게 된다.

tanS = y/z
1 = y/z * 1/tanS
d = 1/tanS

View port 화면에 표시하기 위한 정보
원점과, 가로길이, 세로길이

매핑,변환 정사각형을 직사각형으로 변환
---------------------------------------------------
모델의 위치 방향 크기정보 (월드 변환)

가상의 카메라 (위치와 방향) 의 역변환
카메라 변환

FOV
투영변환 원근투영 나누기 연산이 가능한 조건?

Viewport 원점과 길이를 알면 화면좌표변환 가능

카메라와 점의 거리 d 가 크면 작게,대충(조명계산 할 필요?)
작으면 크게, 세밀하게(조명처리)
카메라와의 거리에 따라 디테일을 다르게 하는것 
Level of detail (프레임을 조절하는 가장 중요한 부분)

거리에 따라 Level을 나누고 가까이 있는것부터 처리를
줄여간다 Level 밖은 사진으로 대체(sky box)

3d 를 사진으로 줄인다던지, 3D처리의 폴리곤을 줄인다던지

레벨(거리)에 따른 메쉬를 구별하기 위해
배열을 사용할것인기, 링크드리스트를 사용할것인기,
이진트리를 사용할것인지, Search 어떤 탐색 알고리즘을 
이용할것인지. Search: 입력값을 주면 적당한 Output을 찾아내는것

조명 - 반사, 굴절, 그림자

벡터란?
벡터의 덧셈, 뺄셈, 스칼라 곱

벡터
1. 점 = 원점 + 벡터
2. 방향 = 크기와 방향? + 시작점?

요소별 연산 x,y,z 끼리끼리 연산

벡터의 스칼라 곱은 원래의 방향을 유지하거나 반대
방향이 다른방향으로 바뀌는 것은 덧셈

벡터의 정규화 단위벡터 크기가 1인벡터
방향을 나타내는 벡터 normal vector 법선벡터

벡터의 덧셈은 기하학적으로 이동의 수단

점의 연산(점끼리 빼면 벡터이기때문에 벡터의 뺄셈이라 칭함)
A-B = B->A
B-A = A->B
백터의 뺄셈은 이동의 방향을 얻는 수단

이동하는 과정을 보여주기 위해 이동속력이 필요
1.뺄셈의 값을 normalize = 법선벡터 
2.법선벡터 * 이동속도 가 이동벡터
3. 이동벡터를 현재위치에 더하면 이동

벡터의 외적 확인!!

1.clear
2.render
3.present(사용자에게 보여주기)

두 벡터는 비교할 수 없다.
두 점은 비교할 수 있다. 시작점이 원점으로 같기 때문에

외적 한 값(y)가 양수이면 +로 돌고, 음수이면 -로 돈다

내가 평면 앞에있으면 거리는 양수
내가 평면 뒤에있으면 거리는 음수
normal벡터의 방향













